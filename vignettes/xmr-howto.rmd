---
title: "How to use xmr()"
author: "Alex Zanidean"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    css: P:/custom.css
    theme: lumen
    toc: yes
---

If you're not in the right place, maybe you want to go to our [Analysis Home.](Q:\StrategicResearch\Rules and Procedures Folder\Checklists and procedures\Procedure Manual\Data Analysis\Home.html)

```{r, echo = F, message=F}
library(tidyverse)
library(xmrr)

Year <- c(2000:2010)
Measure <- c(55,55,54,56,57,54,43,45,47,54,43)
Group = "A"
df <- tibble(Year,Measure, Group)

Measure <- c(65,65,64,66,67,64,73,75,77,74,53)
Group = "B"

df_group <- bind_rows(df, tibble(Year, Measure, Group))

```

The following is how to use the xmr function in *xmrr*.


##Tidy Data

First, *xmrr::xmr* expects tidy data, with one column for a time variable, and another for the actual measurement variable.

```{r, echo = T}
df
```

##Function {.tabset}

The following is how you use some of the arguments. I show them here one-by-one, but they can be all used at once, and in any order.

###Basic

This is the most basic form of the xmr function. All this snippet does is takes the previous dataframe and pipes it into the xmr function. The only needed arguments for the function to run is a dataframe, and a quoted measurement column.

The default behavior in this function is to **not** recalculate the bounds. 

```{r, echo = T}
df %>% 
  xmr("Measure")
```


###Interval

If you want to specify a different interval of points from the start to generate the benchmark data at, then specify with the interval measure. 

In this example, you're telling the function to use the first 6 points rather than the default (5).

```{r, echo = T}
df %>% 
  xmr("Measure", interval = 6)
```


###Re-calculation

A defining feature of xmrr is it's ability to recalculate the bounds. If you'd like the function to recalculate the bounds using the default rules, then simply define that *recalc& argument as T for true.

```{r, echo = T}
df %>% 
  xmr("Measure", recalc = T)
```


###Rules {.tabset}

The default rules for a shortrun is 3 out of consecutive 4 points closer to upper/lower bound than the central as a short run. The default rule for a longrun is 8 consecutive points on either side of the central line, then to use the first few points as defined by interval to recalculate the bounds.

The rules for recalculating XMR bounds can be defined each time the function runs by supply the arguments a vector of length 2.

####Shortrun
```{r, echo = T}
df %>% 
  xmr("Measure", shortrun = c(4,5)) #four points out of five
```

####Longrun
```{r, echo = T}
df %>% 
  xmr("Measure", longrun = c(8,8)) #use all 8 of 8 points.
```

##Grouping

Often we'll have datasets that contain multiple factors. With dplyr it's possible to pipe a grouped dataframe into the function and have the function operate on a per-group basis. 

We also need to wrap the xmr funciton in the generic do() function for it to work on each group.

```{r, echo = T}
df_group %>% 
  group_by(Group) %>% 
  do(xmr(., "Measure")) %>% 
  arrange(Year)

```

[Analysis Home](Q:\StrategicResearch\Rules and Procedures Folder\Checklists and procedures\Procedure Manual\Data Analysis\Home.html)
